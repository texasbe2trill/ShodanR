---
title: "Parsing Data from Shodan API in R"
author: "Chris Campbell"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: '3'
    number_sections: true
  pdf_document:
    toc: true
    toc_depth: '3'
  word_document:
    toc: true
    toc_depth: '3'
always_allow_html: true
---

# Introduction

This R Markdown file explores data regarding internet-connected devices with via the Shodan API.

## Dependencies

-   **R version**: `r R.version.string`
-   **Required Libraries**: `dplyr`, `ggplot2`, `tidyr`, `httr2`, `stringr`, 
`ggthemes`, `renv`, `plotly`, `htmltools`, `maps`, `knitr`, `kableExtra`, 
`jsonlite`

```{r setup, message=F, echo=T, results='hide'}
#Load required libraries
library(dplyr)
library(tidyr)
library(ggplot2)
library(httr2)
library(stringr)
library(ggthemes)
library(renv)
library(jsonlite)
library(plotly)
library(htmltools)
library(maps)
library(knitr)
library(kableExtra)
```

# Input

-   **Shodan API Base URL**:(https://api.shodan.io)

## Query Data from Shodan API

```{r}
# Shodan api key and endpoint
api_key <- Sys.getenv("SHODAN_API_KEY") # Enter your API key here
api_url <- "https://api.shodan.io/shodan/host/search"

# Parameters to query
params <- list(
  key = api_key,
  query = "has_screenshot:true encrypted", # ransomware related query
  limit = 200 # Limit the number of results
)
```

# Retrieve Data from Shodan API

```{r}
# Send the request with httr2
request <- request(api_url) |> 
  req_url_query(!!!params) |> # !!! Splices into key value pairs
  req_throttle(1) # API rate limit

# Perform a request to get the response
response <- req_perform(request)

# Parse the JSON
data <- resp_body_json(response, check_type = T, simplifyVector = T)

# Convert into a dataframe
shodan_df <- data.frame(data$matches)

```


# Tidy Data

```{r , message=F, echo=T, results='hide'}
# Select interesting columns
shodan_df_ransomware <- shodan_df %>%
  select(ip_str, port, transport, product, os, location, screenshot)
# Unnest nested columns
shodan_df_ransomware <- shodan_df_ransomware %>%
  unnest(`screenshot`) %>%
  unnest(`location`)

# Show Column names
colnames(shodan_df_ransomware)

# Select interesting columns from unnested dataframe
shodan_df_ransomware <- shodan_df_ransomware %>%
  select(ip_str, port, transport, product,os, country_name, country_code, city, 
         longitude, latitude, text)

# Rename the columns
colnames(shodan_df_ransomware) <- c("IP Address", "Port", "Transport", "Service", 
                                    "Operating System", "Country", "Country Code",
                                    "City", "Longitude", "Latitude","Ransom Letter")

# Group by Country Code
shodan_df_ransomware <- shodan_df_ransomware %>%
  filter(!is.na(`Ransom Letter`)) %>% # Only keep rows with ransom letters
  group_by(`Country Code`) %>%
  # Arrange by Country
  arrange(Country)

# Write the data to a CSV file
write.csv(shodan_df_ransomware, "~/R/ShodanR/docs/shodan_ransomware.csv", row.names = FALSE)

```

# Data Analysis of Ransomware Infections

```{r}
# Create a frequency table with the counts
common_country_count <- table(shodan_df_ransomware$Country)
common_country_count <- sort(common_country_count, decreasing = TRUE) # Sort the count in descending order

# Count the number of times values in Country appear
shodan_count <- shodan_df_ransomware %>%
  group_by(`Country Code`, `City`, `Longitude`, `Latitude`) %>%
  count(Country)


# Get the names of the counts
common_country_names <- names(common_country_count)

# Get the most common country
most_common_country <- common_country_names[common_country_count == max(common_country_count)]
# Collapse the most common country into a single string
#most_common_country <- paste(most_common_country, collapse = ", ")


# Output the most common country
# If the most common country is the United States
if (length(most_common_country) > 1) {
  
  country_text <- paste(most_common_country, collapse = ", ")
  
  cat("According to the Shodan dataset,", country_text,
      "are the countries with the highest number of ransomware infections, with",
      max(common_country_count), "incidents.", 
    
    # Display the total number of ransomware infections
     "There are a total of", nrow(shodan_df_ransomware), "ransomware infections worldwide!", "\n",
     "\n",
    
    # Statistical Analysis
    "The average number of ransomware infections per country is", 
    round(mean(common_country_count), 2), "\n",  # Average
    
    "The median number of ransomware infections per country is",
    median(common_country_count), "\n", # Median
    
    "The standard deviation of ransomware infections per country is",
    round(sd(common_country_count), 2), "\n") # Standard Deviation
  
} else {
  
  cat("According to the Shodan dataset,", most_common_country,
      "is the country with the highest number of ransomware infections, with",
      max(common_country_count), "incidents.",
    
# Display the total number of ransomware infections
   "There are a total of", nrow(shodan_df_ransomware), "ransomware infections worldwide!", "\n",
   "\n",

  # Statistical Analysis
  "The average number of ransomware infections per country is", 
  round(mean(common_country_count), 2), "\n",  # Average

  "The median number of ransomware infections per country is",
  median(common_country_count), "\n", # Median

  "The standard deviation of ransomware infections per country is",
  round(sd(common_country_count), 2), "\n") # Standard Deviation
}

```

## Table of Ransomware Infections by Country
```{r}
# Table of Ransomware Infections by Country
kable(common_country_count, caption = "Ransomware Infections by Country",
      col.names = c("Country", "Number of Infections"), format = "html") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
  scroll_box(width = "100%", height = "500px") # Add a scroll box


```

# Data Visualization of Ransomware Infections

## Ransomware Infections by Country and City (ggplot2)

```{r, fig.width=10, fig.height=6, fig.retina= 2}
# Create a world map of ransomware infections
ggplot(shodan_count, aes(x = Longitude, y = Latitude, color = `Country`, size = n)) + 
  borders("world", colour = "gray50", fill = "gray50") +
  # Remove Antarctica
  #coord_quickmap(xlim = c(-180, 180), ylim = c(-60, 90)) +
  geom_point() +
  theme_map() +
  labs(title = "Ransomware Infections by Country and City",
       caption = "Source: Shodan API",
       x = "Longitude",
       y = "Latitude",
       color = "Country Code") +
  theme_fivethirtyeight() +
  # Remove the gridlines and axis labels
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none", # Removes the fill legend
        plot.title = element_text(hjust = 0.5)) # Center the title
```

## Interactive Ransomware Infections Map (plotly)

```{r, fig.width=10, fig.height=6, fig.retina= 2}
# Make the map interactive
p <- ggplot(shodan_count, aes(x = Longitude, y = Latitude, 
                              color = `Country`, size = n, 
                              text = paste(" City:", `City`, "<br>", "Country:", `Country`,
                                           "<br>", "Number of Infections:", n))) +
  borders("world", colour = "gray50", fill = "gray50") +
  # Remove Antarctica
  #coord_quickmap(xlim = c(-180, 180), ylim = c(-60, 90)) +
  geom_point() +
  theme_map() +
  labs(title = "Ransomware Infections by Country and City",
       caption = "Source: Shodan API",
       x = "Longitude",
       y = "Latitude",
       color = "Country Code") +
  theme_fivethirtyeight() +
  # Remove the gridlines and axis labels
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        axis.text.x = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks = element_blank(),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        legend.position = "none", # Removes the fill legend
        plot.title = element_text(hjust = 0.5)) # Center the title

ggplotly(p, tooltip = "text") %>%
  layout(hoverlabel = list(
    align = "left"
  ))
```
